# Algorithm activity

## Part 1: Peanut butter & jelly algorithm video

1. Play video of example Peanut Butter and Jelly Algorithm:
<https://youtu.be/cDA3_5982h8> (7:22)\
\
You may choose to cut this short when students get the idea.


## Part 2: Write algorithms

1. In pairs or small groups, students will attempt to develop an algorithm to teach a robot to perform the selected algorithm (e.g., make a peanut butter and jelly sandwich).
2. To divide students into groups, you can use physical location (pairs sitting next to each other), student roster grouping, or you can use the MakeCode Arcade random group generator program: <https://makecode.com/_TDu9qEdE6Txk>
3. 3. Specify to students that their algorithm must be complete and detailed enough for a "computer" (the teacher) to unambiguously follow the steps and achieve the desired result.
4. Give the students 10 minutes to choose a task and write their algorithms\
\
Refrain from giving too much guidance at this stage, as the confusion and errors that are likely to result will reinforce the importance of specificity and detail (and provide entertainment value later!)\
\
Algorithms should be written on paper to be shared and reviewed. Students should not be writing any code or developing algorithms in their heads.\

**Remote Learning Guidance:** This activity could be done using a shared document and links. Consider pairing students in advance or creating a process for students to pair up throughout the semester.

## Part 3: Algorithm execution

1. After the groups have finished, ask them to volunteer to read their instructions to you. Act as the “computer” and follow each step as literally as possible. If there is ambiguity or if a step is not possible to complete, point out the error. 

2. When an instruction is ambiguous or impossible, interpret the algorithm in the most atypical—and hilarious—way possible. This will reinforce to students that seemingly clear instructions can sometimes be interpreted in different ways.
3. Some common errors in instructions:
\
a. Specificity – not being very exact/clear what to do (open jar by twisting the lid counter-clockwise and lifting)\
b. Sequencing – not doing things in the correct order\
c. Orientation/Position – to hold/approach objects\
d. Instructions that are too broad/vague – open to various different interpretations\
e. Combining multiple steps into one instruction\

## Part 4: Improving algorithms

1. Lead a discussion debriefing on the algorithms we saw running:\
a. What did you think of these algorithms?\
b. Which one worked the best? Why?\
c. Which one went very wrong? Why\
2. Briefly explain that programming is an iterative process and that errors are to be expected.
3. Have students spend the next 10 minutes improving their algorithms and attempt to fix all errors and ambiguities.\
a. Changes should be made on paper.\
b. Consider introducing a standard notation for edits to make corrections easier to spot. For example:\
&nbsp;&nbsp;&nbsp;&nbsp;i. Strike-through for deletion\
&nbsp;&nbsp;&nbsp;&nbsp;ii. Caret (^) for insertion\
&nbsp;&nbsp;&nbsp;&nbsp;iii. Circle for modify\
c. If possible, have students make changes using a different colored marker or pen.\
d. While students are working, circulate and give feedback. 

## Part 5: Execute revised algorithms

1. Once groups have finished writing the second version of their algorithm, have them test execution of their algorithm with a neighboring group.
2. Remind students that computers are dumb machines; if they are playing the role of the computer, they must execute each instruction in the algorithm exactly as written.
3. Circulate to observe algorithms in action! Many algorithms will still have similar problems to the first iteration. Some will have too much detail and some not enough (e.g., skipping trivial steps like putting the two slices of bread together). Try to take notes of issues while circulating so you surface them during the debrief discussion.
