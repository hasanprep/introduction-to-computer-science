Lab Introduction
Define pickups.
Anything the player can collect in a game can be referred to as a pickup.
Animating pickups when they are collected can add visual interest to the game.
Define the double jump.
The double jump allows a player who has jumped once to jump again before they land (while still in the air).
Normally, there are some restrictions in place:
They can only jump once in midair (not multiple times).
They can only jump after a jump, not a fall.
Sometimes you can only jump when moving up.
This requires code in several places.
A variable to track how many jumps the player has taken.
A way to check that variable before allowing the player to jump.
A way to set it back to zero when the player lands.
The first two occur in the on button pressed handler. The last one requires code in the on game update handler.
Define jumping on an enemy.
This technique is used in many games to defeat enemies.
It requires you to track where the player and enemy are when they collide with each other.
If the player jumps on an enemy, then the player’s y coordinate will be smaller than the enemy’s.
If so, you can destroy the enemy and award points.
Else, you can remove a life from the player.
You can make any other changes here as well.
Destroy the enemy with different effects.
Give the player a small jump when they land on the enemy.
Create a pickup for the player.
Students are also shown how to change the sprite kind when they jump on it.
They may not realize this is possible, but the kind is just another aspect of the sprite, such as its x position or acceleration.
This allows them to do things like turn an enemy into a useful item or a projectile.
Explain about delayed actions and why they are important.
In the lab, students will have the opportunity to change Enemy sprites into Projectile sprites and back again.
This sets up a race between the event handlers for Player-Enemy collisions and Player-Projectile collisions.
The Player-Enemy event handler will turn the Enemy into a Projectile.
This causes the Player-Projectile event handler to be called, which turns the Projectile back into an Enemy.
This causes the Player-Enemy event handler to be called again, which causes the Player-Projectile event handler to be called, and so on.
This can lead to code which locks up or causes other problems with game play.
The race happens because, when the sprite kind changes, the Player is still overlapping the sprite.
Students can avoid the race by waiting until the Player is no longer overlapping the sprite to change its kind.
Show students the sprite overlaps condition.
This condition works similarly to the on sprite overlaps event handler.
Instead of defining a function which is run immediately when two sprites overlap, the on sprite overlaps condition simply returns true or false if the two sprites are overlapping.
Students can use this at any time to check if a sprite is overlapping another.
Describe how flags work.
A flag is any value, usually a Boolean value, which indicates some condition has been met.
Usually, flags are set in one part of the code and checked or used in another part of the code.
For example, the game over block ends the game but sets a flag indicating whether the game is won or lost.
Makecode uses that flag to show the proper end of game text.
Students can define and use their own flags
Define a variable at the top of their program and set it to false.
Whenever they want to make something happen, set the flag to true.
In the on game update event handler, check if the flag is true or false.
If it is true, do whatever action is necessary.
If false, do nothing.
Show students how to use flags and the on sprite overlaps block to delay changing a Projectile into an Enemy.
Define a variable called changeProjectile and set it to false at the beginning of the game.
In the event handler for Player and Projectile collisions, just set the changeProjectile flag to true.
In the on game update event handler, add an if changeProjectile block to see if we want to change the sprite kind to Enemy.
Inside the true branch of that if block, add another if block which checks that the Player sprite is not overlapping the Projectile sprite.
Inside the true branch of that if block, change the Projectile sprite kind to Enemy and reset the changeProjectile flag to false so it’s ready for the next change.
Introduce the concept of the coyote jump
Named after the well-known super-genius and Acme stockholder Wile E. Coyote.
Whenever he ran off a cliff or mesa, he wouldn’t fall immediately, but only after he noticed he should.
The idea of coyote jump (also called coyote time) is similar: instead of falling immediately after a sprite leaves the platform, the player is given a short amount of time to make a jump.
The amount of time is up to the programmer, but it is usually just a few frames.
Show students how to implement a coyote jump
When the player walks off a platform, they begin to fall.
Their vy then becomes positive and increases based on their acceleration.
Normally, jumps are only allowed when the player’s vy is 0.
For the coyote jump, you can allow jumps while the player’s vy is relatively small (say 1/10th the size of gravity).
Like all other settings, the coyote jump value can be tuned and should be kept in a variable rather than a magic number.
Review the Student Guide 5.4 document with the students. Make sure they understand the rubric for the lab.
Review the questions at the end of each section and the quiz at the end of the lab. 
